[TOC]

# 编译实验文档

## 一、词法分析

词法分析部分我采用的是大自动机模式，自动机如下：

![词法分析](./词法分析.png)

-----



## 二、语法分析

### 文法改写

解决左递归问题：
$$
\begin{flalign}
&\ AddExp \rightarrow MulExp \ |\ AddExp\ ('+'\ |\ '−')\ MulExp \tag{1}\\
=>&\ AddExp \rightarrow MulExp\ \{\ ('+'\ |\ '−')\ MulExp\ \}\\
\\
&\ MulExp \rightarrow UnaryExp\ |\ MulExp\ ('*'\ |\ '/'\ |\ '\%')\ UnaryExp \tag{2} \\
=>&\ MulExp \rightarrow UnaryExp\ \{\ ('*'\ |\ '/'\ |\ '\%')\ UnaryExp\ \}\\
\\
&\ LOrExp \rightarrow LAndExp\ |\ LOrExp\ '||'\ LAndExp \tag{3}\\
=>&\ LOrExp \rightarrow LAndExp\ \{\ '||'\ LAndExp\ \}\\
\\
&\ LAndExp \rightarrow EqExp\ |\ LAndExp\ '\&\&'\ EqExp \tag{4}\\
=>&\ LAndExp \rightarrow EqExp\ \{\ '\&\&'\ EqExp\ \}\\
\\
&\ EqExp \rightarrow RelExp\ |\ EqExp\ ('=='\ |\ '!=')\ RelExp \tag{5}\\
=>&\ EqExp \rightarrow RelExp\ \{\ ('=='\ |\ '!=')\ RelExp\ \}\\
\\
&\ RelExp \rightarrow AddExp\ |\ RelExp\ ('<'\ |\ '>'\ |\ '<='\ |\ '>=')\ AddExp \tag{6}\\
=>&\ RelExp \rightarrow AddExp\ \{\ ('<'\ |\ '>'\ |\ '<='\ |\ '>=')\ AddExp\  \}\\
\end{flalign}
$$

###架构设计

我采用的分析方法为语法分析、词法分析和语义分析在一遍（Pass）中完成，每个非终结符都新建一个类，存储其直接推导出的语法成分，解析的入口为**CompUnit**，之后依照文法进行递归下降的分析方法，解析的过程中如果需要读取一个终结符，则调用**Lexer**类提供的接口读取一个单词，最后自顶向下建立出一颗语法树。

我采用的是分析和输出分离的模式，在输出时也同样会从顶层模块**CompUnit**开始，逐层调用类似前序遍历的方式遍历整颗语法树。采用这种输出方法可以更好的分离输出和分析的过程，并且可以选择是否进行输出。

###难点解决

1. **回溯问题**：因为文法中不可避免的存在回溯，大部分情况都可以通过预读来解决，由于我的**Lexer**采用的是自动机形式，只需要在预读前记录自动机的状态，预读结束后恢复就可达到预读的效果。
2. **特殊回溯问题**：在**Stmt**中可推导出**Exp**和**LVal '=' ( 'getint''('')'| Exp) ';'**，二者可能具有完全相同的前序——**LVal**，并且通过预读也很难分辨出其二者。我采取的做法的直接解析一个**Lval**，之后如果读到的是**=**则正常进行**LVal '=' ( 'getint''('')'| Exp) ';'**的解析，如果不是，将**LVal**作为一个参数传递到**Exp**的解析中，这样避免了重复解析，可以提升运行的效率。
3. **输出问题**：改写左递归文法之后，语法树的结果发生了变化，输出自然也会发生变化，因为我采用的分析和输出相分离的模式，按改写后的文法解析后，“伪装”成原本左递归文法的形式输出即可

------



## 三、错误处理和符号表管理

### 词法错误和语法错误

这两种类型的错误都与符号表无关，利用留在语法分析和词法分析的错误接口即可轻松完成，包括有*非法符号*、*缺少分号*、*缺少右小括号*和*缺少右中括号*这几种错误

### 符号表设计

我采用的是**栈式散列符号表**，符号表分为三级：

- **generalTable**：总表，实际上为一个栈，存储有当前各级符号表，一个符号表在作用域开始时入栈，作用域结束后出栈，栈顶始终为当前符号表，低索引即为高索引的父表
- **SymbolTable**：符号表，保存当前作用域中定义的所有符号，并拥有指向父级的指针，符号在表中以散列形式存储，**key**为符号的**ident**
- **Symbol**：符号类，实际上由两个子类**Variate**和**Function**实现，分别代表变量和函数

在符号表中查找一个符号将会优先查找当前符号表（即栈顶的符号表），若未找到则寻找其父级符号表，以此类推直到找到或者找到没有父级的符号表（栈底符号表）。

### 符号表的建立与删除

- **初始表**：在语法分析开始前先新建一个**SymbolTable**将其放入**generalTable**中，此表只有在语法分析完成之后才会被删除。

- **一般情况**：我们很容易发现一般只有在**Block**中才需要进行建表的操作，所以我们只需要在解析到**Block**前新建**SymbolTable**并将其压入栈中，**Block**解析完毕后弹出栈删除。

- **特殊情况**：在特殊的语句**if**和**for**中可以在不出现**Block**的情况下建表，故我们需要在这两种语句中进行特殊的判断，手动的进行建表和删除

### 符号表相关错误

| 错误类型                             | 错误类别码 | 处理方式                                                     |
| ------------------------------------ | ---------- | ------------------------------------------------------------ |
| 名字重定义                           | b          | 声明语句中，将符号存入当前表中之前先查当前的**SymbolTable**，如果本身已存在则报错 |
| 未定义的名字                         | c          | 引用语句中，先查**generalTable**，如果ident不存在则报错      |
| 函数参数个数不匹配                   | d          | 查表获得函数定义时实参数量，不相同则报错                     |
| 函数参数类型不匹配                   | e          | 查表获得函数定义时实参维度，计算**Exp**维度看是否匹配        |
| 无返回值的函数存在不匹配的return语句 | f          | 只需检查函数块中存在的return语句，不存在视为正确             |
| 有返回值的函数缺少return 语句        | g          | 只需检查函数块最后一条**stmt**，注意**return；**不视为错误   |
| 不能改变常量的值                     | h          | 查表获得变量定义时的类型                                     |
| printf中格式字符与表达式个数不匹配   | l          | 提供检索**ForamtString**中**%d**数量的方法，与后面**Exp**数量比较即可 |
| 在非循环块中使用break和 continue语句 | m          | **for**语句块进行特殊标记，查表获得当前语句块在不在**for**语句块中 |

### 难点解决

1. **函数形参存表问题**：函数形参不在**Block**块中，但实际上应该属于**Block**块中定义的变量，而同时，函数的形参数量和对应维度必须记录在**Function**中，即**Block**的父级符号表中。我的做法是预存，将函数的形参先预存在下一个**SymbolTable**符号表中，但此符号表先不入栈，在**Block**中才压入栈中，这样便将形参存入了子符号表中。
2. **函数实参维度判断**：函数的实参实际上为一个**Exp**，我们需要进行实参和形参维度的比较久必须求得一个**Exp**的维度，我们同样可以使用递归下降的思想求得其维度，在**Exp**类中提供一个**getDim**方法，**Exp**最终会推导到一个**UnaryExp**或者**PrimaryExp**在其二者中通过**Ident**查表可以得知维度，再逐级返回，即可求得**Exp**的维度
3. **缺少分号的报错行号问题**：在缺少分号时，因为词法分析器设计的原因，此时已经指向下一个单词位置，可能与原本语句不在同一行，我在**Lexer**新增一个方法，记录上一个单词的行号，在发现缺少分号错误时，调用此方法找到上一个单词的位置。
